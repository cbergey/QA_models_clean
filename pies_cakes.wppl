//  -----------
// | utilities |
//  ----------

var butLast = function(xs){
  return xs.slice(0, xs.length-1);
};

var KL = function(dist1, dist2){
  var values = dist1.support();
  return sum(map(function(value){
    var scoreP = dist1.score(value);
    var scoreQ = dist2.score(value);
    var probP = Math.exp(scoreP);
    var probQ = Math.exp(scoreQ);
    return (probP == 0.0 ? 0.0 :
            probQ == 0.0 ? 1000:
            probP * (scoreP - scoreQ));
  }, values));
};

var powerset = function(set) {
  if (set.length == 0) {
    return [[]];
  } else {
    var rest = powerset(set.slice(1));
    return map(function(element) {
      return [set[0]].concat(element);
    }, rest).concat(rest);
  }
};

var params = {
  respondantAlpha : 3,
  questionerAlpha : 5,
  relevanceBeta: 0.5, // beta=1 for only action-utility
  costWeight: 1
};

var bakedGoods = ['raspPie', 'raspCake', 'lemonPie', 'lemonCake'];
var setsOfBakedGoods = map(
  function(v){return v.join('+');},
  // add possibility to encode background knowledge of number k of available goods
  filter(function(x) {return x.length <= 4}, powerset(bakedGoods))
);
// console.log(setsOfBakedGoods);
var pieCakeContext = {
  // worlds include all possible sub-sets of 0 < k < N pies and cakes
  worlds : setsOfBakedGoods,

  // actions include ordering 1 pie/cake
  actions: bakedGoods,

  // questions include yes/no question for each baked good
  questions: [
    {type: 'polar-disjunct', queried: ['lemonPie'], text: 'anyLemonPie?'},
    {type: 'polar-disjunct', queried: ['lemonCake'], text: 'anyLemonCake?'},
    {type: 'polar-disjunct', queried: ['raspPie'], text: 'anyRaspPie?'},
    {type: 'polar-disjunct', queried: ['raspCake'], text: 'anyRaspCake?'},
    {type: 'polar-disjunct', queried: ['lemonPie', 'raspPie'], text: 'anyPie?'},
    {type: 'polar-disjunct', queried: ['lemonCake', 'raspCake'], text: 'anyCake?'},
    {type: 'polar-disjunct', queried: ['lemonCake', 'raspCake', 'lemonPie', 'raspPie'], text: 'anything?'},
    // MF additional disjunctions
    {type: 'polar-disjunct', queried: ['lemonPie', 'lemonCake'], text: 'anyLemon?'},
    {type: 'polar-disjunct', queried: ['raspPie', 'raspCake'], text: 'anyRaspberry?'},
    {type: 'polar-disjunct', queried: ['lemonPie', 'raspCake'], text: 'lemonPieOrRaspCake?'},
    {type: 'polar-disjunct', queried: ['lemonCake', 'raspPie'], text: 'lemonCakeOrRaspPie?'},
    {type: 'wh', queried: ['lemonCake', 'raspCake'], text: 'whichCakes?'},
    {type: 'wh', queried: ['lemonPie', 'raspPie'], text: 'whichPies?'},
    {type: 'wh', queried: ['lemonPie', 'lemonCake', 'raspPie', 'raspCake'], text: 'which?'},
  ],

  // assume questioner is uncertain but answerer has Delta on true world (e.g. shopkeep)
  questionerBeliefs: Categorical({vs: setsOfBakedGoods}),
  respondantBeliefs: Delta({v: 'lemonPie+lemonCake'}),

  // raspberry pie is #1 preference (U=5), lemon cake is #2 preference (U=4).
  // otherwise U=1 if whatever you order is in stock and 0 if it's not in stock
  decisionProblem: function(w, a) {
    return _.includes(w, a) ? (a == 'raspPie' ? 5 : a == 'lemonCake' ? 4 : 1) : 0.0000001;
  },

  meaning: function(world, question, response) {
    if(response == '') {
      // assume silence has null meaning
      return true;
    }
    if(question.type == 'polar-disjunct') {
      // assume simplest meaning: 'yes' is true if any item in
      // question is available o.w. 'no' is true
      return (response == 'yes' ? _.intersection(world.split('+'), question.queried).length > 0 :
              response == 'no' ?  _.intersection(world.split('+'), question.queried).length == 0 :
              console.error('unknown response', response));
    } else if(question.type == 'wh') {
      // assume response is true when the shop contains every mentioned item
      return all(function(item) {
        return _.includes(world.split('+'), item);
      }, response.split('+'));
    } else {
      return console.error('question type not yet supported: ' + question.type);
    }
  },

  // R0 chooses among responses licensed by the question
  getLicensedResponses: function(question) {
    if(question.type == 'polar-disjunct') {
      // by definition polar questions require 'yes'/'no' answer
      return ['yes', 'no'];
    } else if(question.type == 'wh') {
      // 'wh' questions allow you to say any set of queried items
      return map(function(v){return v.join('+');}, powerset(question.queried));
    } else {
      return console.error('question type not yet supported: ' + question.type);
    }
  }
};

// amended context with unbiased questioner beliefs and no preferences over any baked good
var pieCakeContextUnbiasedNoPref = extend(
  pieCakeContext,
  {
    // respondant knows true answer
    respondantBeliefs: Delta({v: 'lemonCake'}),
    // no preferences over baked goods
    decisionProblem: function(w, a) {
      return _.includes(w, a) ? 1 : 0.0000001;
    }
  }
)

// amended context with biased questioner beliefs and no preferences over any baked good
var pieCakeContextBiasedNoPref = extend(
  pieCakeContextUnbiasedNoPref,
  {
    // assume questioner is virtually certain that they have either raspberry pie
    // or lemon cake (but not both)
    questionerBeliefs: Categorical({
      vs: setsOfBakedGoods,
      ps: map(
        function (x) {
          return x == 'raspPie' ? 1000 : x == 'lemonCake' ? 1000 : 1
        },
        setsOfBakedGoods
      )
    })
  }
)

var abcdWorlds = ['a', 'b', 'c', 'd', 'e', 'f']
var neutralContext = {
  // worlds include all possible sub-sets of 0 < k < N pies and cakes
  worlds : abcdWorlds,

  // actions include ordering 1 pie/cake
  actions: abcdWorlds,

  // questions include yes/no question for each baked good
  questions: [
    {type: 'polar-disjunct', queried: ['a'], text: 'a?'},
    {type: 'polar-disjunct', queried: ['b'], text: 'b?'},
    {type: 'polar-disjunct', queried: ['c'], text: 'c?'},
    {type: 'polar-disjunct', queried: ['d'], text: 'd?'},
    {type: 'polar-disjunct', queried: ['c'], text: 'e?'},
    {type: 'polar-disjunct', queried: ['d'], text: 'f?'},
    {type: 'wh', queried: ['a', 'b', 'c', 'd', 'e', 'f'], text: 'which?'},
  ],

  // assume questioner is uncertain but answerer has Delta on true world (e.g. shopkeep)
  questionerBeliefs: Categorical({vs: abcdWorlds}),
  respondantBeliefs: Delta({v: 'a'}),

  // raspberry pie is #1 preference (U=5), lemon cake is #2 preference (U=4).
  // otherwise U=1 if whatever you order is in stock and 0 if it's not in stock
  decisionProblem: function(w, a) {
    return w == a;
  },

  meaning: function(world, question, response) {
    if(response == '') {
      // assume silence has null meaning
      return true;
    }
    if(question.type == 'polar-disjunct') {
      return (response == 'yes' ? (world == question.text.charAt(0)) :
              response == 'no' ?  (world != question.text.charAt(0)) : 0);
    } else if(question.type == 'wh') {
      return world == response;
    } else {
      return console.error('question type not yet supported: ' + question.type);
    }
  },

  // R0 chooses among responses licensed by the question
  getLicensedResponses: function(question) {
    if(question.type == 'polar-disjunct') {
      return ['yes', 'no'];
    } else if(question.type == 'wh') {
      return abcdWorlds;
    } else {
      return console.error('question type not yet supported: ' + question.type);
    }
  }
};

// response cost is proportional to length in words
var cost = function(response) {
  // MF: fixed error and added parameter
  return params.costWeight * (response.split('+').length - 1);
};

// weight possible actions proportional
var relevanceProjection = function(beliefs, context) {
  return Infer({method: 'enumerate'}, function() {
    var action = uniformDraw(context.actions);
    var world = sample(beliefs);
    var decisionProblem = context.decisionProblem;
    // console.log(world, action);
    // console.log(Math.log(decisionProblem(world, action)));
    factor(Math.log(decisionProblem(world, action)));
    return action;
  });
};

// gives updated beliefs about world state after hearing response to question
// based on a literal interpretation of the response
var updateBeliefs = function(beliefs, question, response, context) {
  var meaning = context.meaning;
  return Infer({method: 'enumerate'}, function() {
    var world = sample(beliefs);
    condition(meaning(world, question, response));
    return world;
  });
};

// agents weigh (1) general epistemic goal, (2) action-oriented goal, and (3) production cost
var utility = function(type, utterance, beliefs1, beliefs2, context) {
  // respondant wants to *minimize* KL b/w beliefs (bringing closer to own belief)
  // questioner wants to *maximize* KL b/w old & new beliefs (asking informative Q)
  var signFlip = type == 'R0' ? -1 : 1;
  var epistemicUtility = KL(beliefs1, beliefs2) * signFlip;
  var actionUtility = KL(relevanceProjection(beliefs1, context),
                         relevanceProjection(beliefs2, context)) * signFlip;
//   console.log(type + ' considering utterance: ', utterance);
//   console.log('epistemic term:', epistemicUtility);
//   console.log('action-specific term:', actionUtility);
//   console.log('cost term:', cost(utterance));
//   console.log('--------------');
  return ((1 - params.relevanceBeta) * epistemicUtility
          + params.relevanceBeta * actionUtility
          - cost(utterance));
};

var R0 = cache(function(question, context) {
  var getLicensedResponses = context.getLicensedResponses;
  return Infer({method: 'enumerate'}, function(){
    var response = uniformDraw(getLicensedResponses(question));
//     console.log(response);
    var ownBeliefs = context.respondantBeliefs;
    var otherBeliefs = updateBeliefs(context.questionerBeliefs, question, response, context);
//     console.log('updated beliefs', otherBeliefs);
    factor(params.respondantAlpha * utility('R0', response, ownBeliefs, otherBeliefs, context));
    return response;
  });
});

// gives updated beliefs about world state after hearing response to question
// based on a pragmatic interpretation of the response (as emitted by R0)
var updateBeliefsPragmatic = function(beliefs, question, response, context) {
  var meaning = context.meaning;
  return Infer({method: 'enumerate'}, function() {
    var world = sample(beliefs);
    var pragmaticResponse = R0(question, extend(context, {
      respondantBeliefs: Delta({v: world})
    }));
    observe(pragmaticResponse,response)
    return world;
  });
};

var Q1 = function(context) {
  return Infer({method: 'enumerate'}, function(){
    var question = uniformDraw(context.questions);
    // console.log('considering question', question);
    var expectedUtility = expectation(context.questionerBeliefs, function(trueWorld) {
      // console.log('in possible world', trueWorld);
      var possibleResponses = R0(question, extend(context, {
        respondantBeliefs: Delta({v: trueWorld})
      }));
      return expectation(possibleResponses, function(response) {
        var currBeliefs = context.questionerBeliefs;
        var updatedBeliefs = updateBeliefsPragmatic(currBeliefs, question, response, context);
        return utility('Q1', question.text, updatedBeliefs, currBeliefs, context);
      });
    });
    factor(params.questionerAlpha * expectedUtility);
    return question.text;
  });
};

// console.log('====================');
// console.log('R0 test 1: "do you have lemon pie?"');
// console.log('====================');
// var lemonPieQuestion = pieCakeContext.questions[0];
// console.log(R0(lemonPieQuestion, pieCakeContext));

// console.log('====================');
// console.log('R0 test 2: "do you have raspberry pie?"');
// console.log('====================');
// var raspberryPieQuestion = pieCakeContext.questions[2];
// console.log(R0(raspberryPieQuestion, pieCakeContext));

// console.log('====================');
// console.log('R0 test 3:', pieCakeContext.questions[4].text);
// console.log('====================');
// var anyPieQuestion = pieCakeContext.questions[4];
// console.log(R0(anyPieQuestion, pieCakeContext));

// console.log('====================');
// console.log('R0 test 4:', pieCakeContextUnbiasedNoPref.questions[12].text);
// console.log('====================');
// var whichPieQuestion = pieCakeContextUnbiasedNoPref.questions[12];
// console.log(R0(whichPieQuestion, pieCakeContextUnbiasedNoPref));

// console.log('====================');
// console.log('R0 test 5:', pieCakeContextUnbiasedNoPref.questions[13].text);
// console.log('====================');
// var whichThingQuestion = pieCakeContextUnbiasedNoPref.questions[13];
// console.log(R0(whichThingQuestion, pieCakeContextUnbiasedNoPref));

console.log('====================');
console.log('Q1 test, unbiased, w/ preferences');
console.log('====================');
viz(Q1(pieCakeContext))

console.log('====================');
console.log('Q1 test, biased, w/o preferences');
console.log('====================');
viz(Q1(pieCakeContextBiasedNoPref))

console.log('====================');
console.log('Q1 test, UNbiased, w/o preferences');
console.log('Expected: higher prob of "which" than w/ bias ');
console.log('====================');
viz(Q1(pieCakeContextUnbiasedNoPref))

viz(Q1(neutralContext))
