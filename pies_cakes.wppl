//  -----------
// | utilities |
//  ----------

var butLast = function(xs){
  return xs.slice(0, xs.length-1);
};

var KL = function(dist1, dist2){                       
  var values = dist1.support();
  return sum(map(function(value){
    var scoreP = dist1.score(value);
    var scoreQ = dist2.score(value);
    var probP = Math.exp(scoreP);
    var probQ = Math.exp(scoreQ);
    return (probP == 0.0 ? 0.0 :
            probQ == 0.0 ? 100 :
            probP * (scoreP - scoreQ));
  }, values));
};

var powerset = function(set) {
  if (set.length == 0) {
    return [[]];
  } else {
    var rest = powerset(set.slice(1));
    return map(function(element) {
      return [set[0]].concat(element);
    }, rest).concat(rest);
  }
};

var params = {
  respondantAlpha : 1,
  questionerAlpha : 5, 
  relevanceBeta: 0.5
};

var bakedGoods = ['raspPie', 'raspCake', 'lemonPie', 'lemonCake'];
var setsOfBakedGoods = map(function(v){return v.join('+');}, powerset(bakedGoods));
console.log(setsOfBakedGoods);
var pieCakeContext = {
  // worlds include all possible sub-sets of 0 < k < N pies and cakes
  worlds : setsOfBakedGoods,

  // actions include ordering 1 pie/cake
  actions: bakedGoods,

  // questions include yes/no question for each baked good
  questions: [
    {type: 'polar-disjunct', queried: ['lemonPie'], text: 'anyLemonPie?'},
    {type: 'polar-disjunct', queried: ['lemonCake'], text: 'anyLemonCake?'},
    {type: 'polar-disjunct', queried: ['raspPie'], text: 'anyRaspPie?'},
    {type: 'polar-disjunct', queried: ['raspCake'], text: 'anyRaspCake?'},
    {type: 'polar-disjunct', queried: ['lemonPie', 'raspPie'], text: 'anyPie?'},
    {type: 'polar-disjunct', queried: ['lemonCake', 'raspCake'], text: 'anyCake?'},
    {type: 'polar-disjunct', queried: ['lemonCake', 'raspCake', 'lemonPie', 'raspPie'], text: 'anything?'}, 
    {type: 'wh', queried: ['lemonCake', 'raspCake'], text: 'whichCakes?'},
    {type: 'wh', queried: ['lemonPie', 'raspPie'], text: 'whichPies?'},
    {type: 'wh', queried: ['lemonPie', 'lemonCake', 'raspPie', 'raspCake'], text: 'which?'},
  ],

  // assume questioner is uncertain but answerer has Delta on true world (e.g. shopkeep)
  questionerBeliefs: Categorical({vs: setsOfBakedGoods}),
  respondantBeliefs: Delta({v: 'lemonPie+lemonCake'}),

  // raspberry pie is #1 preference (U=5), lemon cake is #2 preference (U=3).
  // otherwise U=1 if whatever you order is in stock and 0 if it's not in stock
  decisionProblem: function(w, a) {
    return _.includes(w, a) ? (a == 'raspPie' ? 5 : a == 'lemonCake' ? 4 : 1) : 0.0000001;
  },
  
  meaning: function(world, question, response) {
    if(response == '') {
      // assume silence has null meaning 
      return true;
    } if(question.type == 'polar-disjunct') {
      // assume simplest meaning: 'yes' is true if any item in
      // question is available o.w. 'no' is true
      return (response == 'yes' ? _.intersection(world.split('+'), question.queried).length > 0 :
              response == 'no' ?  _.intersection(world.split('+'), question.queried).length == 0 :
              console.error('unknown response', response));
    } else if(question.type == 'wh') {
      // assume response is true when the shop contains every mentioned item
      return all(function(item) {
        return _.includes(world.split('+'), item);
      }, response.split('+'));
    } else {
      return console.error('non-polar questions not yet supported');
    }
  }
};

// R0 chooses among responses licensed by the question
var getLicensedResponses = function(question) {
  if(question.type == 'polar-disjunct') {
    // by definition polar questions require 'yes'/'no' answer
    return ['yes', 'no'];
  } else if(question.type == 'wh') {
    // 'wh' questions allows you to say any set of queried items (essentially mention-some)
    return map(function(v){return v.join('+');}, powerset(question.queried));
  } else {
    return console.error('non-polar questions not yet supported');
  }
};

// response cost is proportional to length in words
var cost = function(response) {
  return response.split(' ').length;
};

// weight possible actions proportional 
var relevanceProjection = function(beliefs, context) {
  return Infer({method: 'enumerate'}, function() {
    var action = uniformDraw(context.actions);
    var world = sample(beliefs);
    var decisionProblem = context.decisionProblem;
    // console.log(world, action);
    // console.log(Math.log(decisionProblem(world, action)));
    factor(Math.log(decisionProblem(world, action)));
    return action;
  });
};

  // gives updated beliefs about world state after hearing response to question
var updateBeliefs = function(beliefs, question, response, context) {
  var meaning = context.meaning;
  return Infer({method: 'enumerate'}, function() {
    var world = sample(beliefs);
    condition(meaning(world, question, response));
    return world;
  });
};

// agents weigh (1) general epistemic goal, (2) action-oriented goal, and (3) production cost
var utility = function(type, utterance, beliefs1, beliefs2, context) {
  // respondant wants to *minimize* KL b/w beliefs (bringing closer to own belief)
  // questioner wants to *maximize* KL b/w old & new beliefs (asking informative Q)
  var signFlip = type == 'R0' ? -1 : 1;
  var epistemicUtility = KL(beliefs1, beliefs2) * signFlip;
  var actionUtility = KL(relevanceProjection(beliefs1, context),
                         relevanceProjection(beliefs2, context)) * signFlip;
  console.log(type + ' considering utterance: ', utterance);
  console.log('epistemic term:', epistemicUtility);
  console.log('action-specific term:', actionUtility);
  console.log('cost term:', cost(utterance));
  console.log('--------------');
  return ((1 - params.relevanceBeta) * epistemicUtility 
          + params.relevanceBeta * actionUtility
          - cost(utterance));
};

var R0 = cache(function(question, context) {
  return Infer({method: 'enumerate'}, function(){
    var response = uniformDraw(getLicensedResponses(question));
    var ownBeliefs = context.respondantBeliefs;
    var otherBeliefs = updateBeliefs(context.questionerBeliefs, question, response, context);
    console.log('updated beliefs', otherBeliefs);
    factor(params.respondantAlpha * utility('R0', response, ownBeliefs, otherBeliefs, context));
    return response;
  });
});

var Q1 = cache(function(context) {
  return Infer({method: 'enumerate'}, function(){
    var question = uniformDraw(context.questions);
    console.log('considering question', question);
    var expectedUtility = expectation(context.questionerBeliefs, function(trueWorld) {
      console.log('in possible world', trueWorld);
      var possibleResponses = R0(question, extend(context, {
        respondantBeliefs: Delta({v: trueWorld})
      }));
      return expectation(possibleResponses, function(response) {
        var currBeliefs = context.questionerBeliefs;
        var updatedBeliefs = updateBeliefs(currBeliefs, question, response, context);
	return utility('Q1', question.text, updatedBeliefs, currBeliefs, context);
      });
    });
    factor(params.questionerAlpha * expectedUtility);
    return question;
  });
});

console.log('====================');
console.log('R0 test 1: "do you have lemon pie?"');
console.log('====================');
var lemonPieQuestion = pieCakeContext.questions[0];
console.log(R0(lemonPieQuestion, pieCakeContext));

console.log('====================');
console.log('R0 test 2: "do you have raspberry pie?"');
console.log('====================');
var raspberryPieQuestion = pieCakeContext.questions[2];
console.log(R0(raspberryPieQuestion, pieCakeContext));

console.log('====================');
console.log('R0 test 3:', pieCakeContext.questions[4]);
console.log('====================');
var anyPieQuestion = pieCakeContext.questions[4];
console.log(R0(anyPieQuestion, pieCakeContext));

console.log('====================');
console.log('R0 test 4:', pieCakeContext.questions[8]);
console.log('====================');
var whichPieQuestion = pieCakeContext.questions[8];
console.log(R0(whichPieQuestion, pieCakeContext));

console.log('====================');
console.log('R0 test 5:', pieCakeContext.questions[9]);
console.log('====================');
var whichThingQuestion = pieCakeContext.questions[9];
console.log(R0(whichThingQuestion, pieCakeContext));

console.log('====================');
console.log('Q1 test');
console.log('====================');
console.log(Q1(pieCakeContext));
