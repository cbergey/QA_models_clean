// Context model for the credit card example (Case study 2: World state priors).



// full power-set baked goods examples (from presentations)

// we consider three credit cards: American Express (AE), MasterCard (MC), and Carte Blanche (CB)
var creditCards = ['AE', 'MC', 'CB'];
// the context set is the power set of the credit cards (= which cards are accepted))
var creditCardsContextSets = prepareContextSets(creditCards);
var setsOfcreditCards      = creditCardsContextSets.powerSet;
var R1WHResponses          = creditCardsContextSets.R1WHResponses;
var R1PolarResponses       = creditCardsContextSets.R1PolarResponses;

var creditCardContext = {

  name : "CCC_hiPri_AE",

  // worlds are what the questioner is uncertain about and what the answerer knows
  // here, that's the set of credit cards the restaurant actually accepts
  worlds : setsOfcreditCards,

  // actions: stay of go
  actions: ['stay', 'go'],

  // questions: yes/no question for each non-empty set of credit cards + wh-question about any credit cards
  questions: [
    {type: 'single-item', queried: ['AE'], text: 'AE?'},
    {type: 'single-item', queried: ['MC'], text: 'MC?'},
    {type: 'single-item', queried: ['CB'], text: 'CB?'},
    {type: 'polar-disjunct', queried: ['AE', 'MC'], text: 'AE or MC?'},
    {type: 'polar-disjunct', queried: ['AE', 'CB'], text: 'AE or CB?'},
    {type: 'polar-disjunct', queried: ['MC', 'CB'], text: 'MC or CB?'},
    {type: 'polar-disjunct', queried: ['AE', 'MC', 'CB'], text: 'Any?'},
    {type: 'wh', queried: ['AE', 'MC', 'CB'], text: 'Which?'}
  ],

  // assume questioner is uncertain but answerer has Delta on true world (e.g. shopkeep)
  questionerBeliefs: Categorical({vs: setsOfcreditCards}),
  // TODO check if this is correct!? It would be the high-prior condition
  R0PriorOverWorlds: Delta({v: 'AE+MC'}),
  R1PriorOverWorlds: Delta({v: 'AE+MC'}),

  // Q wants to choose "go" iff the restaurant accepts at least one credit card they have,
  // so, payoffs define implicitly what kinds of cards the Q has
  // per default, this implements a respondent who only has AE
  decisionProblem: function(w, a) {
    return _.includes(w, 'AE') ?
      (a == 'go' ? 5 : 0) :
      (a == 'go' ? 0 : 5);
  },

  // R0 chooses among responses licensed by the question
  getLicensedResponsesR0: function(question) {
    if(question.type == 'single-item') {
      // by definition polar questions require 'yes'/'no' answer
      return ['yes', 'no'];
    } else if(question.type == 'polar-disjunct') {
      // by definition polar questions require 'yes'/'no' answer
      var answers = ['yes', 'no'].concat(question.queried);
      return answers;
    } else if(question.type == 'wh') {
      // 'wh' questions allow you to say any set of queried items,
      // or to say "nothing" when none of the querried items exist
      return replaceEmptyListWithStringNothing(
        map(
          function(v){return v.join('+');},
          powerset(question.queried)
        ));
    } else {
      return console.error('question type not yet supported: ' + question.type);
    }
  },

  // R1 chooses among responses licensed by the question
  getLicensedResponsesR1: function(question) {
    return (question.type == 'wh' ?
            R1WHResponses : R1PolarResponses)
  },
  // semantic meaning function
  meaning: meaningFunction
};

// // amended context with feature-based (additive) preferences
// var pieCakeContextAdditivePreferences = extend(
//   pieCakeContext,
//   {
//     name : "pieCake-prefs-additive",
//     // feature-additive preferences: pie = 2, cake = 1, rasp = 6, lemon = 4;
//     decisionProblem: function(w, a) {
//       return _.includes(w, a) ? (a == 'raspPie'   ? 8/2 :
//                                  a == 'raspCake'  ? 7/2 :
//                                  a == 'lemonPie'  ? 6/2 :
//                                  a == 'lemonCake' ? 5/2 :
//                                  a == 'nothing'   ? 1/2 :
//                                  console.error('unknown action')
//                                 ) : 0.0000001;
//     }
//   }
// )


// // --------------------------------------
// // R1 prior beliefs over various contexts
// // --------------------------------------

// // R1 does not know the belief state of the questioner
// var R1PriorContext_beliefsQ1 = {
//   confident: pieCakeContextBiasedNoPref,
//   unbiased:  pieCakeContextUnbiasedNoPref,
//   pessimist: pieCakeContextBiasedPessimist,
//   distribution: Categorical({vs: ["confident" , "unbiased",  "pessimist"]})
// }

// // R1 does not know the preferences of the questioner
// var R1PriorContext_PreferenceQ1 = {
//   raspCake:  pieCakeContextAdditivePreferences,
//   PieLemon:  pieCakeContextAdditivePreferencesReversed,
//   distribution: Categorical({vs: ["raspCake" , "PieLemon"]})
// }

// // R1 does not know the preferences of the questioner
// var R1PriorContext_BinaryPrefs = {
//   raspberry: pieCakeContext_raspberry,
//   lemon    : pieCakeContext_lemon,
//   distribution: Categorical({vs: ["raspberry" , "lemon"]})
// }
