// Context model for the credit card example (Case study 2: World state priors).



// full power-set baked goods examples (from presentations)

// we consider three credit cards: American Express (AE), MasterCard (MC), and Carte Blanche (CB)
var creditCards = ['AE', 'MC', 'CB'];
// the context set is the power set of the credit cards (= which cards are accepted))
var creditCardsContextSets = prepareContextSets(creditCards);
var setsOfcreditCards      = creditCardsContextSets.powerSet;
var R1WHResponses          = creditCardsContextSets.R1WHResponses;
var R1PolarResponses       = creditCardsContextSets.R1PolarResponses;

var creditCardContext = {

  name : "CCC_hiPri_AE",

  // worlds are what the questioner is uncertain about and what the answerer knows
  // here, that's the set of credit cards the restaurant actually accepts
  worlds : setsOfcreditCards,

  // actions: stay of go
  actions: ['stay', 'go'],

  // questions: yes/no question for each non-empty set of credit cards + wh-question about any credit cards
  questions: [
    {type: 'single-item', queried: ['AE'], text: 'AE?'},
    {type: 'single-item', queried: ['MC'], text: 'MC?'},
    {type: 'single-item', queried: ['CB'], text: 'CB?'},
    {type: 'polar-disjunct', queried: ['AE', 'MC'], text: 'AE or MC?'},
    {type: 'polar-disjunct', queried: ['AE', 'CB'], text: 'AE or CB?'},
    {type: 'polar-disjunct', queried: ['MC', 'CB'], text: 'MC or CB?'},
    {type: 'polar-disjunct', queried: ['AE', 'MC', 'CB'], text: 'Any?'},
    {type: 'wh', queried: ['AE', 'MC', 'CB'], text: 'Which?'}
  ],

  // assume questioner is uncertain but answerer has Delta on true world (e.g. shopkeep)
  questionerBeliefs: Categorical({
    vs: setsOfcreditCards,
    // TODO: assuming non-uniform priors introduces many degrees of freedom; predictions can depend on it
    // ps: [ 30, // AE+MC+CB
    //       80, // AE+MC
    //       25, // AE+CB
    //       70, // AE
    //       15, // MC+CB
    //       55, // MC
    //       5, // CB
    //       10 // nothing
    //     ]
  }),
  // TODO check if this is correct!? It would be the high-prior condition
  R0PriorOverWorlds: Delta({v: 'AE+MC'}),
  R1PriorOverWorlds: Delta({v: 'AE+MC'}),

  // Q wants to choose "go" iff the restaurant accepts at least one credit card they have,
  // so, payoffs define implicitly what kinds of cards the Q has
  // per default, this implements a respondent who only has AE
  decisionProblem: function(w, a) {
    return _.includes(w, 'AE') ?
      (a == 'go' ? 5 : 0) :
      (a == 'go' ? 0 : 5);
  },

  // R0 chooses among responses licensed by the question
  getLicensedResponsesR0: function(question) {
    if(question.type == 'single-item') {
      // by definition polar questions require 'yes'/'no' answer
      return ['yes', 'no'];
    } else if(question.type == 'polar-disjunct') {
      // by definition polar questions require 'yes'/'no' answer
      var answers = ['yes', 'no'].concat(question.queried);
      return answers;
    } else if(question.type == 'wh') {
      // 'wh' questions allow you to say any set of queried items,
      // or to say "nothing" when none of the querried items exist
      return replaceEmptyListWithStringNothing(
        map(
          function(v){return v.join('+');},
          powerset(question.queried)
        ));
    } else {
      return console.error('question type not yet supported: ' + question.type);
    }
  },

  // R1 chooses among responses licensed by the question
  getLicensedResponsesR1: function(question) {
    return (question.type == 'wh' ?
            R1WHResponses : R1PolarResponses)
  },
  // semantic meaning function
  meaning: meaningFunction
};

// create all relevant contexts:
// - highPrior: Restaurant has AE+MC
// - lowPrior:  Restaurant has MC+CB
// - medPrior:  Restaurant has AE+CB
// in all cases, questioner owns one of {AE, MC, CB}
//
// Case Studies:
// 1. highPrior and lowPrior with question "Any?"
// 2. highPrior and lowPrior with question "MC?"
// 3. medPrior  with question "MC?"


// create context function --------

// INPUT:
// contextName       : STR         | internal name of context      | "CCC_hiPri_AE_MC"
// trueWorld         : STR         | which cards the store accepts | "AE+MC"
// payoffVector      : LST (reals) | payoffs in row-first forma    | [1,0,0,1]
// whichCCDoesR1Have : STR         | which cards the customer has  | "MC+CB"

var createContext = function(contextName, trueWorld, payoffVector, whichCCDoesR1Have) {
  var newContext = extend(
    creditCardContext,
    {
      name: contextName,
      R0PriorOverWorlds: Delta({v: trueWorld}),
      R1PriorOverWorlds: Delta({v: trueWorld}),
      decisionProblem: function(w, a) {
        return _.intersection(_.split(w, '+'), _.split(whichCCDoesR1Have, '+')).length > 0 ?
        (a == 'go' ? payoffVector[0] : payoffVector[1]) :
        (a == 'go' ? payoffVector[2] : payoffVector[3]);
      }}
  )
  return(newContext)
}

// highPrior contexts --------------

var CCC_hiPri_AE       = createContext('CCC_hiPri_AE'      , 'AE+MC', [5,0,0,5], 'AE')
var CCC_hiPri_MC       = createContext('CCC_hiPri_MC'      , 'AE+MC', [5,0,0,5], 'MC')
var CCC_hiPri_CB       = createContext('CCC_hiPri_CB'      , 'AE+MC', [5,0,0,5], 'CB')
var CCC_hiPri_AE_MC    = createContext('CCC_hiPri_AE_MC'   , 'AE+MC', [5,0,0,5], 'AE+MC')
var CCC_hiPri_AE_CB    = createContext('CCC_hiPri_AE_CB'   , 'AE+MC', [5,0,0,5], 'AE+CB')
var CCC_hiPri_MC_CB    = createContext('CCC_hiPri_MC_CB'   , 'AE+MC', [5,0,0,5], 'MC_CB')
var CCC_hiPri_AE_MC_BC = createContext('CCC_hiPri_AE_MC_CB', 'AE+MC', [5,0,0,5], 'AE_MC_CB')

var R1Prior_Uncertainty_highPior = {
  AE          : CCC_hiPri_AE,
  MC          : CCC_hiPri_MC,
  CB          : CCC_hiPri_CB,
  AE_MC       : CCC_hiPri_AE_MC,
  AE_CB       : CCC_hiPri_AE_CB,
  MC_CB       : CCC_hiPri_MC_CB,
  AE_MC_CB    : CCC_hiPri_AE_MC_BC,
  distribution: Categorical({vs: ["AE", "MC", "CB", "AE_MC", "AE_CB", "MC_CB", "AE_MC_CB"], ps: [6,4,1,5,3,2,4]})
}

// lowPrior contexts --------------

var CCC_loPri_AE       = createContext('CCC_loPri_AE'      , 'MC+CB', [5,0,0,5], 'AE')
var CCC_loPri_MC       = createContext('CCC_loPri_MC'      , 'MC+CB', [5,0,0,5], 'MC')
var CCC_loPri_CB       = createContext('CCC_loPri_CB'      , 'MC+CB', [5,0,0,5], 'CB')
var CCC_loPri_AE_MC    = createContext('CCC_loPri_AE_MC'   , 'MC+CB', [5,0,0,5], 'AE+MC')
var CCC_loPri_AE_CB    = createContext('CCC_loPri_AE_CB'   , 'MC+CB', [5,0,0,5], 'AE+CB')
var CCC_loPri_MC_CB    = createContext('CCC_loPri_MC_CB'   , 'MC+CB', [5,0,0,5], 'MC_CB')
var CCC_loPri_AE_MC_BC = createContext('CCC_loPri_AE_MC_CB', 'MC+CB', [5,0,0,5], 'AE_MC_CB')

var R1Prior_Uncertainty_lowPior = {
  AE          : CCC_loPri_AE,
  MC          : CCC_loPri_MC,
  CB          : CCC_loPri_CB,
  AE_MC       : CCC_loPri_AE_MC,
  AE_CB       : CCC_loPri_AE_CB,
  MC_CB       : CCC_loPri_MC_CB,
  AE_MC_CB    : CCC_loPri_AE_MC_BC,
  distribution: Categorical({vs: ["AE", "MC", "CB", "AE_MC", "AE_CB", "MC_CB", "AE_MC_CB"], ps: [6,4,1,5,3,2,4]})
}

// medPrior contexts --------------

var CCC_medPri_AE       = createContext('CCC_medPri_AE'      , 'AE+CB', [5,0,0,5], 'AE')
var CCC_medPri_MC       = createContext('CCC_medPri_MC'      , 'AE+CB', [5,0,0,5], 'MC')
var CCC_medPri_CB       = createContext('CCC_medPri_CB'      , 'AE+CB', [5,0,0,5], 'CB')
var CCC_medPri_AE_MC    = createContext('CCC_medPri_AE_MC'   , 'AE+CB', [5,0,0,5], 'AE+MC')
var CCC_medPri_AE_CB    = createContext('CCC_medPri_AE_CB'   , 'AE+CB', [5,0,0,5], 'AE+CB')
var CCC_medPri_MC_CB    = createContext('CCC_medPri_MC_CB'   , 'AE+CB', [5,0,0,5], 'MC_CB')
var CCC_medPri_AE_MC_BC = createContext('CCC_medPri_AE_MC_CB', 'AE+CB', [5,0,0,5], 'AE_MC_CB')

var R1Prior_Uncertainty_medPior = {
  AE          : CCC_medPri_AE,
  MC          : CCC_medPri_MC,
  CB          : CCC_medPri_CB,
  AE_MC       : CCC_medPri_AE_MC,
  AE_CB       : CCC_medPri_AE_CB,
  MC_CB       : CCC_medPri_MC_CB,
  AE_MC_CB    : CCC_medPri_AE_MC_BC,
  distribution: Categorical({vs: ["AE", "MC", "CB", "AE_MC", "AE_CB", "MC_CB", "AE_MC_CB"], ps: [6,4,1,5,3,2,4]})
}
